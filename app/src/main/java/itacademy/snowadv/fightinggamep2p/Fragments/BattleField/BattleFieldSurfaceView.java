package itacademy.snowadv.fightinggamep2p.Fragments.BattleField;import android.content.Context;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.graphics.Canvas;import android.graphics.Color;import android.graphics.Paint;import android.graphics.Rect;import android.graphics.Typeface;import android.text.TextPaint;import android.util.Log;import android.view.SurfaceHolder;import android.view.SurfaceView;import androidx.annotation.NonNull;import androidx.core.content.res.ResourcesCompat;import androidx.fragment.app.Fragment;import java.util.Calendar;import itacademy.snowadv.fightinggamep2p.Classes.DrawableBattleUnits.DrawableBattleUnit;import itacademy.snowadv.fightinggamep2p.Classes.DrawablesContainer;import itacademy.snowadv.fightinggamep2p.Classes.Field;import itacademy.snowadv.fightinggamep2p.Classes.Notifiable;import itacademy.snowadv.fightinggamep2p.Classes.Server.GameServer;import itacademy.snowadv.fightinggamep2p.Classes.Server.Packets.ChatMessage;import itacademy.snowadv.fightinggamep2p.Classes.Server.Packets.GameActionRequest;import itacademy.snowadv.fightinggamep2p.Fragments.Lobby.BattlePlayer;import itacademy.snowadv.fightinggamep2p.Fragments.ServerList.Callback;import itacademy.snowadv.fightinggamep2p.R;/*package-private*/ class BattleFieldSurfaceView extends SurfaceView implements SurfaceHolder.Callback {    private static final String TAG = "BattleFieldSurfaceView";    private final Context context;    private final ServerBattleFragment serverBattleFragment;    private BattleFieldDrawThread drawThread;    private final DrawablesContainer drawables = new DrawablesContainer();    private Bitmap background;    private GameServer gameServer;    public BattleFieldSurfaceView(Context context, GameServer gameServer, ServerBattleFragment serverBattleFragment) {        super(context);        this.context = context;        this.gameServer = gameServer;        gameServer.setCallbackForBattleSurfaceView(object -> {            if(drawThread == null || drawThread.isInterrupted()) {                return; // Return if drawing thread is dead            }            if(object instanceof ChatMessage) {                ChatMessage msg = (ChatMessage) object;                serverBattleFragment.addChatMessageToLog(msg);            } else if(object instanceof GameActionRequest) {                GameActionRequest request = (GameActionRequest) object;                switch(request.action) {                    case ABILITY:                        request.player.getAssignedBattleUnit().ability(request.player, context,                                gameServer.getGameStatsPacket().getPlayersList());                        break;                    case HARD_KICK:                        request.player.getAssignedBattleUnit().hardKick(request.player, context,                                request.affectedPlayer);                        break;                    case LIGHT_KICK:                        request.player.getAssignedBattleUnit().lightKick(request.player, context,                                request.affectedPlayer);                }            }        });        this.serverBattleFragment = serverBattleFragment;        getHolder().addCallback(this);    }    @Override    public void surfaceCreated(@NonNull SurfaceHolder surfaceHolder) {        Log.d(TAG, "Surface created;");        drawThread = new BattleFieldDrawThread(surfaceHolder, getContext());        drawThread.start();    }    @Override    public void surfaceChanged(@NonNull SurfaceHolder surfaceHolder, int i, int i1, int i2) {        Log.d(TAG, "Surface changed;");    }    @Override    public void surfaceDestroyed(@NonNull SurfaceHolder surfaceHolder) {        Log.d(TAG, "Surface destroyed;");        drawThread.interrupt();        drawables.clear();        gameServer.stopServer();    }    private void addChatMessageToLog(ChatMessage message) {    }    private class BattleFieldDrawThread extends Thread{        private final SurfaceHolder surfaceHolder;        private Paint paint;        private TextPaint textPaint;        private Context parentContext;        private static final int FPS = 10;        Calendar calendar;        private  long nextUpdateTime;        public BattleFieldDrawThread(SurfaceHolder surfaceHolder, Context parentContext) {            background = BitmapFactory.decodeResource(context.getResources(),                    R.drawable.green_background);            this.surfaceHolder = surfaceHolder;            this.parentContext = parentContext;            calendar = Calendar.getInstance();            nextUpdateTime = calendar.getTimeInMillis();            initTools();        }        private void initTools() {            paint = new Paint();            textPaint = new TextPaint();            textPaint.setTextSize(50);            textPaint.setTextAlign(Paint.Align.CENTER);            textPaint.setColor(Color.BLACK);            Typeface typeface = ResourcesCompat.getFont(context, R.font.gouranga_pixel);            textPaint.setTypeface(typeface);            paint.setColor(Color.GREEN);            paint.setStyle(Paint.Style.FILL);        }        @Override        public void run() {            // Creates field objects            Field.spawnFieldsAndCopy(gameServer.getGameStatsPacket().getEvilPlayersAmount()                    , gameServer.getGameStatsPacket().getKindPlayersAmount(),                    getWidth(), getHeight(), context, drawables);            // Gets battle unit for every battle player and assigns it to the field            BattlePlayer.assignAllBattleUnitsToFields(                    gameServer.getGameStatsPacket().getPlayersList(), context);            // Add all battle units to drawables            BattlePlayer.addAllBattleUnitsToDrawables(gameServer                    .getGameStatsPacket().getPlayersList(), drawables);            // Send updated gamestats with assigned battleunits to everyone            gameServer.sendStartEventToEveryone();            while(!interrupted()){                if(nextUpdateTime - calendar.getTimeInMillis() > 0) {                    try {                        Thread.sleep(nextUpdateTime - calendar.getTimeInMillis());                    } catch(InterruptedException ex) {                        /*                        Interrupted exception will always be called when Thread.sleep() called                        so there's no need to handle it                         */                    }                }                nextUpdateTime = calendar.getTimeInMillis() + 1000/FPS;                Canvas canvas = surfaceHolder.lockCanvas();                if(canvas == null) continue;                if(getWidth() < getHeight()) { // In case the device in portrait mode                    serverBattleFragment.changeHUDVisibility(GONE);                    // Draw green background                    canvas.drawColor(Color.WHITE);                    canvas.drawText("Переверните устройство для того,", getWidth()/2f,                            getHeight()/2f, textPaint);                    canvas.drawText("чтобы продолжить отрисовку", getWidth()/2f ,                            getHeight()/2f + 50, textPaint);                } else { // Game drawing starts here                    serverBattleFragment.changeHUDVisibility(VISIBLE);                    // Draw green background                    canvas.drawBitmap(background, null, new Rect(0, 0, getWidth(),                            getHeight()), paint);                    // Draw all drawables                    drawables.drawAllDrawablesOnCanvas(canvas);            }                surfaceHolder.unlockCanvasAndPost(canvas);        }    }    }}